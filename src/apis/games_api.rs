/*
 * Lichess.org API reference
 *
 * # Introduction Welcome to the reference for the Lichess API! Lichess is free/libre, open-source chess server powered by volunteers and donations. - Get help in the [Lichess Discord channel](https://discord.gg/lichess) - API demo app with OAuth2 login and gameplay: [source](https://github.com/lichess-org/api-demo) / [demo](https://lichess-org.github.io/api-demo/) - API UI app with OAuth2 login and endpoint forms: [source](https://github.com/lichess-org/api-ui) / [website](https://lichess.org/api/ui) - [Contribute to this documentation on Github](https://github.com/lichess-org/api) - Check out [Lichess widgets to embed in your website](https://lichess.org/developers) - [Download all Lichess rated games](https://database.lichess.org/) - [Download all Lichess puzzles with themes, ratings and votes](https://database.lichess.org/#puzzles) - [Download all evaluated positions](https://database.lichess.org/#evals)  ## Endpoint All requests go to `https://lichess.org` (unless otherwise specified).  ## Clients - [Python general API](https://github.com/lichess-org/berserk) - [MicroPython general API](https://github.com/mkomon/uberserk) - [Python general API - async](https://pypi.org/project/async-lichess-sdk) - [Python Lichess Bot](https://github.com/lichess-bot-devs/lichess-bot) - [Python Board API for Certabo](https://github.com/haklein/certabo-lichess) - [Java general API](https://github.com/tors42/chariot) - [JavaScript & TypeScript general API](https://github.com/devjiwonchoi/equine)  ## Rate limiting All requests are rate limited using various strategies, to ensure the API remains responsive for everyone. Only make one request at a time. If you receive an HTTP response with a [429 status](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429), please wait a full minute before resuming API usage.  ## Streaming with ND-JSON Some API endpoints stream their responses as [Newline Delimited JSON a.k.a. **nd-json**](http://ndjson.org/), with one JSON object per line.  Here's a [JavaScript utility function](https://gist.github.com/ornicar/a097406810939cf7be1df8ea30e94f3e) to help reading NDJSON streamed responses.  ## Authentication ### Which authentication method is right for me? [Read about the Lichess API authentication methods and code examples](https://github.com/lichess-org/api/blob/master/example/README.md)  ### Personal Access Token Personal API access tokens allow you to quickly interact with Lichess API without going through an OAuth flow. - [Generate a personal access token](https://lichess.org/account/oauth/token) - `curl https://lichess.org/api/account -H \"Authorization: Bearer {token}\"` - [NodeJS example](https://github.com/lichess-org/api/tree/master/example/oauth-personal-token)  ### Authorization Code Flow with PKCE The authorization code flow with PKCE allows your users to **login with Lichess**. Lichess supports unregistered and public clients (no client authentication, choose any unique client id). The only accepted code challenge method is `S256`. Access tokens are long-lived (expect one year), unless they are revoked. Refresh tokens are not supported.  See the [documentation for the OAuth endpoints](#tag/OAuth) or the [PKCE RFC](https://datatracker.ietf.org/doc/html/rfc7636#section-4) for a precise protocol description.  - [Demo app](https://lichess-org.github.io/api-demo/) - [Minimal client-side example](https://github.com/lichess-org/api/tree/master/example/oauth-app) - [Flask/Python example](https://github.com/lakinwecker/lichess-oauth-flask) - [Java example](https://github.com/tors42/lichess-oauth-pkce-app) - [NodeJS Passport strategy to login with Lichess OAuth2](https://www.npmjs.com/package/passport-lichess)  #### Real life examples - [PyChess](https://github.com/gbtami/pychess-variants) ([source code](https://github.com/gbtami/pychess-variants)) - [Lichess4545](https://www.lichess4545.com/) ([source code](https://github.com/cyanfish/heltour)) - [English Chess Federation](https://ecf.octoknight.com/) - [Rotherham Online Chess](https://rotherhamonlinechess.azurewebsites.net/tournaments)  ### Token format Access tokens and authorization codes match `^[A-Za-z0-9_]+$`. The length of tokens can be increased without notice. Make sure your application can handle at least 512 characters. By convention tokens have a recognizable prefix, but do not rely on this. 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: contact@lichess.org
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`api_account_playing`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiAccountPlayingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_games_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiGamesUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_imported_games_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiImportedGamesUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_user_current_game`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUserCurrentGameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`game_import`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GameImportError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`game_pgn`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GamePgnError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`games_by_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GamesByIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`games_by_ids_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GamesByIdsAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`games_by_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GamesByUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`games_export_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GamesExportIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stream_game`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StreamGameError {
    UnknownValue(serde_json::Value),
}


/// Get the ongoing games of the current user. Real-time and correspondence games are included. The most urgent games are listed first. 
pub async fn api_account_playing(configuration: &configuration::Configuration, nb: Option<i32>) -> Result<serde_json::Value, Error<ApiAccountPlayingError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/account/playing", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = nb {
        local_var_req_builder = local_var_req_builder.query(&[("nb", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiAccountPlayingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Download all games of any user in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.  Games are sorted by reverse chronological order (most recent first).  We recommend streaming the response, for it can be very long. <https://lichess.org/@/german11> for instance has more than 500,000 games.  The game stream is throttled, depending on who is making the request:   - Anonymous request: 20 games per second   - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second   - Authenticated, downloading your own games: 60 games per second 
pub async fn api_games_user(configuration: &configuration::Configuration, username: &str, since: Option<i32>, until: Option<i32>, max: Option<i32>, vs: Option<&str>, rated: Option<bool>, perf_type: Option<crate::models::PerfType>, color: Option<&str>, analysed: Option<bool>, moves: Option<bool>, pgn_in_json: Option<bool>, tags: Option<bool>, clocks: Option<bool>, evals: Option<bool>, accuracy: Option<bool>, opening: Option<bool>, ongoing: Option<bool>, finished: Option<bool>, literate: Option<bool>, last_fen: Option<bool>, players: Option<&str>, sort: Option<&str>) -> Result<serde_json::Value, Error<ApiGamesUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/games/user/{username}", local_var_configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = since {
        local_var_req_builder = local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = until {
        local_var_req_builder = local_var_req_builder.query(&[("until", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = vs {
        local_var_req_builder = local_var_req_builder.query(&[("vs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = rated {
        local_var_req_builder = local_var_req_builder.query(&[("rated", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = perf_type {
        local_var_req_builder = local_var_req_builder.query(&[("perfType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = color {
        local_var_req_builder = local_var_req_builder.query(&[("color", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = analysed {
        local_var_req_builder = local_var_req_builder.query(&[("analysed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = moves {
        local_var_req_builder = local_var_req_builder.query(&[("moves", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pgn_in_json {
        local_var_req_builder = local_var_req_builder.query(&[("pgnInJson", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tags {
        local_var_req_builder = local_var_req_builder.query(&[("tags", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = clocks {
        local_var_req_builder = local_var_req_builder.query(&[("clocks", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = evals {
        local_var_req_builder = local_var_req_builder.query(&[("evals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = accuracy {
        local_var_req_builder = local_var_req_builder.query(&[("accuracy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = opening {
        local_var_req_builder = local_var_req_builder.query(&[("opening", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ongoing {
        local_var_req_builder = local_var_req_builder.query(&[("ongoing", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = finished {
        local_var_req_builder = local_var_req_builder.query(&[("finished", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = literate {
        local_var_req_builder = local_var_req_builder.query(&[("literate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = last_fen {
        local_var_req_builder = local_var_req_builder.query(&[("lastFen", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = players {
        local_var_req_builder = local_var_req_builder.query(&[("players", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiGamesUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Download all games imported by you. Games are exported in PGN format.
pub async fn api_imported_games_user(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiImportedGamesUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/games/export/imports", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiImportedGamesUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Download the ongoing game, or the last game played, of a user. Available in either PGN or JSON format.  Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API. 
pub async fn api_user_current_game(configuration: &configuration::Configuration, username: &str, moves: Option<bool>, pgn_in_json: Option<bool>, tags: Option<bool>, clocks: Option<bool>, evals: Option<bool>, accuracy: Option<bool>, opening: Option<bool>, literate: Option<bool>, players: Option<&str>) -> Result<serde_json::Value, Error<ApiUserCurrentGameError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/user/{username}/current-game", local_var_configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = moves {
        local_var_req_builder = local_var_req_builder.query(&[("moves", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pgn_in_json {
        local_var_req_builder = local_var_req_builder.query(&[("pgnInJson", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tags {
        local_var_req_builder = local_var_req_builder.query(&[("tags", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = clocks {
        local_var_req_builder = local_var_req_builder.query(&[("clocks", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = evals {
        local_var_req_builder = local_var_req_builder.query(&[("evals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = accuracy {
        local_var_req_builder = local_var_req_builder.query(&[("accuracy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = opening {
        local_var_req_builder = local_var_req_builder.query(&[("opening", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = literate {
        local_var_req_builder = local_var_req_builder.query(&[("literate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = players {
        local_var_req_builder = local_var_req_builder.query(&[("players", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiUserCurrentGameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Import a game from PGN. See <https://lichess.org/paste>.  Rate limiting: 200 games per hour for OAuth requests, 100 games per hour for anonymous requests.  To broadcast ongoing games, consider [pushing to a broadcast instead](#operation/broadcastPush).  To analyse a position or a line, just construct an analysis board URL: [https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+](https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+) 
pub async fn game_import(configuration: &configuration::Configuration, pgn: Option<&str>) -> Result<serde_json::Value, Error<GameImportError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/import", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = pgn {
        local_var_form_params.insert("pgn", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GameImportError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Download one game in either PGN or JSON format.  Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API. 
pub async fn game_pgn(configuration: &configuration::Configuration, game_id: &str, moves: Option<bool>, pgn_in_json: Option<bool>, tags: Option<bool>, clocks: Option<bool>, evals: Option<bool>, accuracy: Option<bool>, opening: Option<bool>, literate: Option<bool>, players: Option<&str>) -> Result<serde_json::Value, Error<GamePgnError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/game/export/{gameId}", local_var_configuration.base_path, gameId=crate::apis::urlencode(game_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = moves {
        local_var_req_builder = local_var_req_builder.query(&[("moves", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pgn_in_json {
        local_var_req_builder = local_var_req_builder.query(&[("pgnInJson", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tags {
        local_var_req_builder = local_var_req_builder.query(&[("tags", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = clocks {
        local_var_req_builder = local_var_req_builder.query(&[("clocks", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = evals {
        local_var_req_builder = local_var_req_builder.query(&[("evals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = accuracy {
        local_var_req_builder = local_var_req_builder.query(&[("accuracy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = opening {
        local_var_req_builder = local_var_req_builder.query(&[("opening", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = literate {
        local_var_req_builder = local_var_req_builder.query(&[("literate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = players {
        local_var_req_builder = local_var_req_builder.query(&[("players", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GamePgnError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a stream of games from an arbitrary streamId, and a list of game IDs.  The stream first outputs the games that already exists, then emits an event each time a game is started or finished.  Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).  Maximum number of games: 500 for anonymous requests, or 1000 for [OAuth2 authenticated](#section/Introduction/Authentication) requests.  While the stream is open, it is possible to [add new game IDs to watch](#operation/gamesByIdsAdd). 
pub async fn games_by_ids(configuration: &configuration::Configuration, stream_id: &str, body: &str) -> Result<serde_json::Value, Error<GamesByIdsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/stream/games/{streamId}", local_var_configuration.base_path, streamId=crate::apis::urlencode(stream_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GamesByIdsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add new game IDs for [an existing stream](#operation/gamesByIds) to watch. The stream will immediately outputs the games that already exists, then emit an event each time a game is started or finished. 
pub async fn games_by_ids_add(configuration: &configuration::Configuration, stream_id: &str, body: &str) -> Result<crate::models::Ok, Error<GamesByIdsAddError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/stream/games/{streamId}/add", local_var_configuration.base_path, streamId=crate::apis::urlencode(stream_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GamesByIdsAddError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Stream the games played between a list of users, in real time. Only games where **both players** are part of the list are included.  The stream emits an event each time a game is started or finished.  To also get all current ongoing games at the beginning of the stream, use the `withCurrentGames` flag.  Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).  Maximum number of users: 300.  The method is `POST` so a longer list of IDs can be sent in the request body. 
pub async fn games_by_users(configuration: &configuration::Configuration, body: &str, with_current_games: Option<bool>) -> Result<serde_json::Value, Error<GamesByUsersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/stream/games-by-users", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_current_games {
        local_var_req_builder = local_var_req_builder.query(&[("withCurrentGames", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GamesByUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Download games by IDs in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.  Games are sorted by reverse chronological order (most recent first)  The method is `POST` so a longer list of IDs can be sent in the request body.  300 IDs can be submitted.  Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API. 
pub async fn games_export_ids(configuration: &configuration::Configuration, body: &str, moves: Option<bool>, pgn_in_json: Option<bool>, tags: Option<bool>, clocks: Option<bool>, evals: Option<bool>, accuracy: Option<bool>, opening: Option<bool>, literate: Option<bool>, players: Option<&str>) -> Result<serde_json::Value, Error<GamesExportIdsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/games/export/_ids", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = moves {
        local_var_req_builder = local_var_req_builder.query(&[("moves", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pgn_in_json {
        local_var_req_builder = local_var_req_builder.query(&[("pgnInJson", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tags {
        local_var_req_builder = local_var_req_builder.query(&[("tags", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = clocks {
        local_var_req_builder = local_var_req_builder.query(&[("clocks", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = evals {
        local_var_req_builder = local_var_req_builder.query(&[("evals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = accuracy {
        local_var_req_builder = local_var_req_builder.query(&[("accuracy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = opening {
        local_var_req_builder = local_var_req_builder.query(&[("opening", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = literate {
        local_var_req_builder = local_var_req_builder.query(&[("literate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = players {
        local_var_req_builder = local_var_req_builder.query(&[("players", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GamesExportIdsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Stream positions and moves of any ongoing game, in [ndjson](#section/Introduction/Streaming-with-ND-JSON).  A description of the game is sent as a first message. Then a message is sent each time a move is played. Finally a description of the game is sent when it finishes, and the stream is closed.  Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.  No more than 8 game streams can be opened at the same time from the same IP address. 
pub async fn stream_game(configuration: &configuration::Configuration, id: &str) -> Result<serde_json::Value, Error<StreamGameError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/stream/game/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StreamGameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

