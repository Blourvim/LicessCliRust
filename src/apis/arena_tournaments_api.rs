/*
 * Lichess.org API reference
 *
 * # Introduction Welcome to the reference for the Lichess API! Lichess is free/libre, open-source chess server powered by volunteers and donations. - Get help in the [Lichess Discord channel](https://discord.gg/lichess) - API demo app with OAuth2 login and gameplay: [source](https://github.com/lichess-org/api-demo) / [demo](https://lichess-org.github.io/api-demo/) - API UI app with OAuth2 login and endpoint forms: [source](https://github.com/lichess-org/api-ui) / [website](https://lichess.org/api/ui) - [Contribute to this documentation on Github](https://github.com/lichess-org/api) - Check out [Lichess widgets to embed in your website](https://lichess.org/developers) - [Download all Lichess rated games](https://database.lichess.org/) - [Download all Lichess puzzles with themes, ratings and votes](https://database.lichess.org/#puzzles) - [Download all evaluated positions](https://database.lichess.org/#evals)  ## Endpoint All requests go to `https://lichess.org` (unless otherwise specified).  ## Clients - [Python general API](https://github.com/lichess-org/berserk) - [MicroPython general API](https://github.com/mkomon/uberserk) - [Python general API - async](https://pypi.org/project/async-lichess-sdk) - [Python Lichess Bot](https://github.com/lichess-bot-devs/lichess-bot) - [Python Board API for Certabo](https://github.com/haklein/certabo-lichess) - [Java general API](https://github.com/tors42/chariot) - [JavaScript & TypeScript general API](https://github.com/devjiwonchoi/equine)  ## Rate limiting All requests are rate limited using various strategies, to ensure the API remains responsive for everyone. Only make one request at a time. If you receive an HTTP response with a [429 status](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429), please wait a full minute before resuming API usage.  ## Streaming with ND-JSON Some API endpoints stream their responses as [Newline Delimited JSON a.k.a. **nd-json**](http://ndjson.org/), with one JSON object per line.  Here's a [JavaScript utility function](https://gist.github.com/ornicar/a097406810939cf7be1df8ea30e94f3e) to help reading NDJSON streamed responses.  ## Authentication ### Which authentication method is right for me? [Read about the Lichess API authentication methods and code examples](https://github.com/lichess-org/api/blob/master/example/README.md)  ### Personal Access Token Personal API access tokens allow you to quickly interact with Lichess API without going through an OAuth flow. - [Generate a personal access token](https://lichess.org/account/oauth/token) - `curl https://lichess.org/api/account -H \"Authorization: Bearer {token}\"` - [NodeJS example](https://github.com/lichess-org/api/tree/master/example/oauth-personal-token)  ### Authorization Code Flow with PKCE The authorization code flow with PKCE allows your users to **login with Lichess**. Lichess supports unregistered and public clients (no client authentication, choose any unique client id). The only accepted code challenge method is `S256`. Access tokens are long-lived (expect one year), unless they are revoked. Refresh tokens are not supported.  See the [documentation for the OAuth endpoints](#tag/OAuth) or the [PKCE RFC](https://datatracker.ietf.org/doc/html/rfc7636#section-4) for a precise protocol description.  - [Demo app](https://lichess-org.github.io/api-demo/) - [Minimal client-side example](https://github.com/lichess-org/api/tree/master/example/oauth-app) - [Flask/Python example](https://github.com/lakinwecker/lichess-oauth-flask) - [Java example](https://github.com/tors42/lichess-oauth-pkce-app) - [NodeJS Passport strategy to login with Lichess OAuth2](https://www.npmjs.com/package/passport-lichess)  #### Real life examples - [PyChess](https://github.com/gbtami/pychess-variants) ([source code](https://github.com/gbtami/pychess-variants)) - [Lichess4545](https://www.lichess4545.com/) ([source code](https://github.com/cyanfish/heltour)) - [English Chess Federation](https://ecf.octoknight.com/) - [Rotherham Online Chess](https://rotherhamonlinechess.azurewebsites.net/tournaments)  ### Token format Access tokens and authorization codes match `^[A-Za-z0-9_]+$`. The length of tokens can be increased without notice. Make sure your application can handle at least 512 characters. By convention tokens have a recognizable prefix, but do not rely on this. 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: contact@lichess.org
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`api_team_arena`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTeamArenaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tournament`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTournamentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tournament_join`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTournamentJoinError {
    Status400(crate::models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tournament_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTournamentPostError {
    Status400(crate::models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tournament_team_battle_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTournamentTeamBattlePostError {
    Status400(crate::models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tournament_terminate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTournamentTerminateError {
    Status400(crate::models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tournament_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTournamentUpdateError {
    Status400(crate::models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tournament_withdraw`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTournamentWithdrawError {
    Status400(crate::models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_user_name_tournament_created`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUserNameTournamentCreatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`games_by_tournament`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GamesByTournamentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`results_by_tournament`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResultsByTournamentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`teams_by_tournament`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamsByTournamentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tournament`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TournamentError {
    UnknownValue(serde_json::Value),
}


/// Get all Arena tournaments relevant to a team.  Tournaments are sorted by reverse chronological order of start date (last starting first).  Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON). 
pub async fn api_team_arena(configuration: &configuration::Configuration, team_id: &str, max: Option<i32>) -> Result<crate::models::ArenaTournament, Error<ApiTeamArenaError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/team/{teamId}/arena", local_var_configuration.base_path, teamId=crate::apis::urlencode(team_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiTeamArenaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get recently finished, ongoing, and upcoming tournaments.  This API is used to display the [Lichess tournament schedule](https://lichess.org/tournament). 
pub async fn api_tournament(configuration: &configuration::Configuration, ) -> Result<crate::models::ArenaTournaments, Error<ApiTournamentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiTournamentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Join an Arena tournament, possibly with a password and/or a team. Also unpauses if you had previously [paused](#operation/apiTournamentWithdraw) the tournament. 
pub async fn api_tournament_join(configuration: &configuration::Configuration, id: &str, password: Option<&str>, team: Option<&str>, pair_me_asap: Option<bool>) -> Result<crate::models::Ok, Error<ApiTournamentJoinError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament/{id}/join", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = password {
        local_var_form_params.insert("password", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = team {
        local_var_form_params.insert("team", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = pair_me_asap {
        local_var_form_params.insert("pairMeAsap", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiTournamentJoinError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a public or private Arena tournament.  This endpoint mirrors the form on <https://lichess.org/tournament/new>.  You can create up to 12 public tournaments per day, or 24 private tournaments.  A team battle can be created by specifying the `teamBattleByTeam` argument.  Additional restrictions:   - clockTime + clockIncrement > 0   - 15s and 0+1 variant tournaments cannot be rated   - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150 
pub async fn api_tournament_post(configuration: &configuration::Configuration, clock_time: f32, clock_increment: i32, minutes: i32, name: Option<&str>, wait_minutes: Option<i32>, start_date: Option<i32>, variant: Option<crate::models::VariantKey>, rated: Option<bool>, position: Option<&str>, berserkable: Option<bool>, streakable: Option<bool>, has_chat: Option<bool>, description: Option<&str>, password: Option<&str>, team_battle_by_team: Option<&str>, conditions_period_team_member_period_team_id: Option<&str>, conditions_period_min_rating_period_rating: Option<i32>, conditions_period_max_rating_period_rating: Option<i32>, conditions_period_nb_rated_game_period_nb: Option<i32>, conditions_period_allow_list: Option<&str>) -> Result<serde_json::Value, Error<ApiTournamentPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = name {
        local_var_form_params.insert("name", local_var_param_value.to_string());
    }
    local_var_form_params.insert("clockTime", clock_time.to_string());
    local_var_form_params.insert("clockIncrement", clock_increment.to_string());
    local_var_form_params.insert("minutes", minutes.to_string());
    if let Some(local_var_param_value) = wait_minutes {
        local_var_form_params.insert("waitMinutes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = start_date {
        local_var_form_params.insert("startDate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = variant {
        local_var_form_params.insert("variant", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = rated {
        local_var_form_params.insert("rated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = position {
        local_var_form_params.insert("position", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = berserkable {
        local_var_form_params.insert("berserkable", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = streakable {
        local_var_form_params.insert("streakable", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = has_chat {
        local_var_form_params.insert("hasChat", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = description {
        local_var_form_params.insert("description", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = password {
        local_var_form_params.insert("password", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = team_battle_by_team {
        local_var_form_params.insert("teamBattleByTeam", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conditions_period_team_member_period_team_id {
        local_var_form_params.insert("conditions.teamMember.teamId", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conditions_period_min_rating_period_rating {
        local_var_form_params.insert("conditions.minRating.rating", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conditions_period_max_rating_period_rating {
        local_var_form_params.insert("conditions.maxRating.rating", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conditions_period_nb_rated_game_period_nb {
        local_var_form_params.insert("conditions.nbRatedGame.nb", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conditions_period_allow_list {
        local_var_form_params.insert("conditions.allowList", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiTournamentPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set the teams and number of leaders of a team battle.  To update the other attributes of a team battle, use the [tournament update endpoint](#operation/apiTournamentUpdate). 
pub async fn api_tournament_team_battle_post(configuration: &configuration::Configuration, id: &str, teams: &str, nb_leaders: i32) -> Result<serde_json::Value, Error<ApiTournamentTeamBattlePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament/team-battle/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("teams", teams.to_string());
    local_var_form_params.insert("nbLeaders", nb_leaders.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiTournamentTeamBattlePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Terminate an Arena tournament 
pub async fn api_tournament_terminate(configuration: &configuration::Configuration, id: &str) -> Result<crate::models::Ok, Error<ApiTournamentTerminateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament/{id}/terminate", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiTournamentTerminateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an Arena tournament.  Be mindful not to make important changes to ongoing tournaments.  Can be used to update a team battle.  Additional restrictions:   - clockTime + clockIncrement > 0   - 15s and 0+1 variant tournaments cannot be rated   - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150 
pub async fn api_tournament_update(configuration: &configuration::Configuration, id: &str, clock_time: f32, clock_increment: i32, minutes: i32, name: Option<&str>, wait_minutes: Option<i32>, start_date: Option<i32>, variant: Option<crate::models::VariantKey>, rated: Option<bool>, position: Option<&str>, berserkable: Option<bool>, streakable: Option<bool>, has_chat: Option<bool>, description: Option<&str>, password: Option<&str>, conditions_period_min_rating_period_rating: Option<i32>, conditions_period_max_rating_period_rating: Option<i32>, conditions_period_nb_rated_game_period_nb: Option<i32>, conditions_period_allow_list: Option<&str>) -> Result<serde_json::Value, Error<ApiTournamentUpdateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = name {
        local_var_form_params.insert("name", local_var_param_value.to_string());
    }
    local_var_form_params.insert("clockTime", clock_time.to_string());
    local_var_form_params.insert("clockIncrement", clock_increment.to_string());
    local_var_form_params.insert("minutes", minutes.to_string());
    if let Some(local_var_param_value) = wait_minutes {
        local_var_form_params.insert("waitMinutes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = start_date {
        local_var_form_params.insert("startDate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = variant {
        local_var_form_params.insert("variant", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = rated {
        local_var_form_params.insert("rated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = position {
        local_var_form_params.insert("position", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = berserkable {
        local_var_form_params.insert("berserkable", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = streakable {
        local_var_form_params.insert("streakable", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = has_chat {
        local_var_form_params.insert("hasChat", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = description {
        local_var_form_params.insert("description", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = password {
        local_var_form_params.insert("password", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conditions_period_min_rating_period_rating {
        local_var_form_params.insert("conditions.minRating.rating", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conditions_period_max_rating_period_rating {
        local_var_form_params.insert("conditions.maxRating.rating", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conditions_period_nb_rated_game_period_nb {
        local_var_form_params.insert("conditions.nbRatedGame.nb", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conditions_period_allow_list {
        local_var_form_params.insert("conditions.allowList", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiTournamentUpdateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Leave a future Arena tournament, or take a break on an ongoing Arena tournament. It's possible to join again later. Points and streaks are preserved. 
pub async fn api_tournament_withdraw(configuration: &configuration::Configuration, id: &str) -> Result<crate::models::Ok, Error<ApiTournamentWithdrawError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament/{id}/withdraw", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiTournamentWithdrawError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all tournaments created by a given user.  Tournaments are sorted by reverse chronological order of start date (last starting first).  Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON). 
pub async fn api_user_name_tournament_created(configuration: &configuration::Configuration, username: &str, status: Option<i32>) -> Result<crate::models::ArenaTournament, Error<ApiUserNameTournamentCreatedError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/user/{username}/tournament/created", local_var_configuration.base_path, username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiUserNameTournamentCreatedError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Download games of a tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.  Games are sorted by reverse chronological order (most recent first).  The game stream is throttled, depending on who is making the request:   - Anonymous request: 20 games per second   - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second 
pub async fn games_by_tournament(configuration: &configuration::Configuration, id: &str, player: Option<&str>, moves: Option<bool>, pgn_in_json: Option<bool>, tags: Option<bool>, clocks: Option<bool>, evals: Option<bool>, accuracy: Option<bool>, opening: Option<bool>) -> Result<serde_json::Value, Error<GamesByTournamentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament/{id}/games", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = player {
        local_var_req_builder = local_var_req_builder.query(&[("player", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = moves {
        local_var_req_builder = local_var_req_builder.query(&[("moves", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pgn_in_json {
        local_var_req_builder = local_var_req_builder.query(&[("pgnInJson", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tags {
        local_var_req_builder = local_var_req_builder.query(&[("tags", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = clocks {
        local_var_req_builder = local_var_req_builder.query(&[("clocks", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = evals {
        local_var_req_builder = local_var_req_builder.query(&[("evals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = accuracy {
        local_var_req_builder = local_var_req_builder.query(&[("accuracy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = opening {
        local_var_req_builder = local_var_req_builder.query(&[("opening", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GamesByTournamentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Players of an Arena tournament, with their score and performance, sorted by rank (best first).  **Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON)**, i.e. one JSON object per line.  If called on an ongoing tournament, results can be inconsistent due to ranking changes while the players are being streamed. Use on finished tournaments for guaranteed consistency. 
pub async fn results_by_tournament(configuration: &configuration::Configuration, id: &str, nb: Option<i32>, sheet: Option<bool>) -> Result<serde_json::Value, Error<ResultsByTournamentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament/{id}/results", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = nb {
        local_var_req_builder = local_var_req_builder.query(&[("nb", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sheet {
        local_var_req_builder = local_var_req_builder.query(&[("sheet", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResultsByTournamentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Teams of a team battle tournament, with top players, sorted by rank (best first). 
pub async fn teams_by_tournament(configuration: &configuration::Configuration, id: &str) -> Result<serde_json::Value, Error<TeamsByTournamentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament/{id}/teams", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamsByTournamentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get detailed info about recently finished, current, or upcoming tournament's duels, player standings, and other info. 
pub async fn tournament(configuration: &configuration::Configuration, id: &str, page: Option<f32>) -> Result<serde_json::Value, Error<TournamentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tournament/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TournamentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

